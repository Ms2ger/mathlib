/-
Copyright (c) 2020 Bhavik Mehta, E. W. Ayers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, E. W. Ayers
-/

import category_theory.sites.grothendieck
import category_theory.sites.pretopology
import category_theory.full_subcategory
import category_theory.types
import category_theory.limits.types
import tactic.equiv_rw

universes v u
namespace category_theory

open category_theory category limits sieve classical

namespace grothendieck_topology

variables {C : Type u} [category.{v} C]

variables {P : C·µí·µñ ‚•§ Type v}
variables {X Y : C} {S : sieve X} {R : presieve X}
variables (J J‚ÇÇ : grothendieck_topology C)

def equiv_to_equalizer (W : C) {X Y Z : C} {f : X ‚ü∂ Y} {g h : Y ‚ü∂ Z} (w : f ‚â´ g = f ‚â´ h)
  (t : is_limit (fork.of_Œπ _ w)) :
(W ‚ü∂ X) ‚âÉ {t : W ‚ü∂ Y // t ‚â´ g = t ‚â´ h} :=
{ to_fun := Œª z, ‚ü®z ‚â´ f, by simp [w]‚ü©,
  inv_fun := Œª q, (fork.is_limit.lift' t _ q.prop).1,
  left_inv := Œª z,
  begin
    dsimp,
    apply fork.is_limit.hom_ext t,
    apply (fork.is_limit.lift' t (z ‚â´ f) _).prop,
  end,
  right_inv :=
  begin
    rintro q,
    apply subtype.ext,
    apply (fork.is_limit.lift' t q.1 _).prop,
  end }

/--
A family of elements for a presheaf `P` given a collection of arrows `R` with fixed codomain `X`
consists of an element of `P Y` for every `f : Y ‚ü∂ X` in `R`.
A presheaf is a sheaf (resp, separated) if every *consistent* family of elements has exactly one
(resp, at most one) amalgamation.
-/
def family_of_elements (P : C·µí·µñ ‚•§ Type v) (R : presieve X) :=
Œ† ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üí P.obj (opposite.op Y)

/--
A family of elements for a presheaf on the arrow set `R‚ÇÇ` can be restricted to a smaller collection
of arrows `R‚ÇÅ`.
-/
def family_of_elements.restrict {R‚ÇÅ R‚ÇÇ : presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) :
  family_of_elements P R‚ÇÇ ‚Üí family_of_elements P R‚ÇÅ :=
Œª x Y f hf, x f (h _ hf)

/--
A family of elements for the arrow set `R` is consistent if for any `f‚ÇÅ : Y‚ÇÅ ‚ü∂ X` and `f‚ÇÇ : Y‚ÇÇ ‚ü∂ X`
in `R`, and any `g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ` and `g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ`, if the square `g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ` commutes then
the elements of `P Z` obtained by restricting the element of `P Y‚ÇÅ` along `g‚ÇÅ` and restricting
the element of `P Y‚ÇÇ` along `g‚ÇÇ` are the same.
-/
def family_of_elements.consistent (x : family_of_elements P R) : Prop :=
‚àÄ ‚¶ÉY‚ÇÅ Y‚ÇÇ Z‚¶Ñ (g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ) (g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ) ‚¶Éf‚ÇÅ : Y‚ÇÅ ‚ü∂ X‚¶Ñ ‚¶Éf‚ÇÇ : Y‚ÇÇ ‚ü∂ X‚¶Ñ
  (h‚ÇÅ : R f‚ÇÅ) (h‚ÇÇ : R f‚ÇÇ), g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ ‚Üí P.map g‚ÇÅ.op (x f‚ÇÅ h‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ h‚ÇÇ)

def family_of_elements.pullback_consistent (x : family_of_elements P R) [has_pullbacks C] : Prop :=
‚àÄ ‚¶ÉY‚ÇÅ Y‚ÇÇ‚¶Ñ ‚¶Éf‚ÇÅ : Y‚ÇÅ ‚ü∂ X‚¶Ñ ‚¶Éf‚ÇÇ : Y‚ÇÇ ‚ü∂ X‚¶Ñ (h‚ÇÅ : R f‚ÇÅ) (h‚ÇÇ : R f‚ÇÇ),
  P.map (pullback.fst : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ _).op (x f‚ÇÅ h‚ÇÅ) = P.map pullback.snd.op (x f‚ÇÇ h‚ÇÇ)

lemma is_pullback_consistent_iff (x : family_of_elements P S) [has_pullbacks C] :
  x.consistent ‚Üî x.pullback_consistent :=
begin
  split,
  { intros t Y‚ÇÅ Y‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ,
    apply t,
    apply pullback.condition },
  { intros t Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm,
    rw [‚Üêpullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf‚ÇÅ hf‚ÇÇ,
        ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, pullback.lift_snd] }
end

/-- The restriction of a consistent family is consistent. -/
lemma family_of_elements.consistent.restrict {R‚ÇÅ R‚ÇÇ : presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ)
  {x : family_of_elements P R‚ÇÇ} : x.consistent ‚Üí (x.restrict h).consistent :=
Œª q Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm, q g‚ÇÅ g‚ÇÇ (h _ h‚ÇÅ) (h _ h‚ÇÇ) comm

/-- Extend a family of elements to the sieve generated by an arrow set. -/
noncomputable def family_of_elements.sieve_extend (x : family_of_elements P R) :
  family_of_elements P (generate R) :=
Œª Z f hf, P.map (some (some_spec hf)).op (x _ (some_spec (some_spec (some_spec hf))).1)

/-- The extension of a consistent family to the generated sieve is consistent. -/
lemma family_of_elements.consistent.sieve_extend (x : family_of_elements P R) (hx : x.consistent) :
  x.sieve_extend.consistent :=
begin
  intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm,
  rw [‚Üê(some_spec (some_spec (some_spec h‚ÇÅ))).2, ‚Üê(some_spec (some_spec (some_spec h‚ÇÇ))).2,
      ‚Üêassoc, ‚Üêassoc] at comm,
  dsimp [family_of_elements.sieve_extend],
  rw [‚Üê functor_to_types.map_comp_apply, ‚Üê functor_to_types.map_comp_apply],
  apply hx _ _ _ _ comm,
end

/-- The extension of a family agrees with the original family. -/
lemma extend_agrees {x : family_of_elements P R} (t : x.consistent) {f : Y ‚ü∂ X} (hf : R f) :
  x.sieve_extend f ‚ü®_, ùüô _, f, hf, id_comp _‚ü© = x f hf :=
begin
  have h : (generate R) f := ‚ü®_, _, _, hf, id_comp _‚ü©,
  change P.map (some (some_spec h)).op (x _ _) = x f hf,
  rw t (some (some_spec h)) (ùüô _) _ hf _,
  { simp },
  simp_rw [id_comp],
  apply (some_spec (some_spec (some_spec h))).2,
end

/-- The restriction of an extension is the original. -/
@[simp]
lemma restrict_extend {x : family_of_elements P R} (t : x.consistent) :
  x.sieve_extend.restrict (le_generate R) = x :=
begin
  ext Y f hf,
  exact extend_agrees t hf,
end

/--
If the arrow set for a family of elements is actually a sieve (i.e. it is downward closed) then the
consistency condition can be simplified.
This is an equivalent condition, see `is_sieve_consistent_iff`.
-/
def family_of_elements.sieve_consistent (x : family_of_elements P S) : Prop :=
‚àÄ ‚¶ÉY Z‚¶Ñ (f : Y ‚ü∂ X) (g : Z ‚ü∂ Y) (hf), x (g ‚â´ f) (S.downward_closed hf g) = P.map g.op (x f hf)

lemma is_sieve_consistent_iff (x : family_of_elements P S) :
  x.consistent ‚Üî x.sieve_consistent :=
begin
  split,
  { intros h Y Z f g hf,
    simpa using h (ùüô _) g (S.downward_closed hf g) hf (id_comp _) },
  { intros h Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ k,
    simp_rw [‚Üê h f‚ÇÅ g‚ÇÅ h‚ÇÅ, k, h f‚ÇÇ g‚ÇÇ h‚ÇÇ] }
end

lemma family_of_elements.consistent.to_sieve_consistent {x : family_of_elements P S}
  (t : x.consistent) : x.sieve_consistent :=
(is_sieve_consistent_iff x).1 t

lemma restrict_inj {x‚ÇÅ x‚ÇÇ : family_of_elements P (generate R)}
  (t‚ÇÅ : x‚ÇÅ.consistent) (t‚ÇÇ : x‚ÇÇ.consistent) :
  x‚ÇÅ.restrict (le_generate R) = x‚ÇÇ.restrict (le_generate R) ‚Üí x‚ÇÅ = x‚ÇÇ :=
begin
  intro h,
  ext Z f ‚ü®Y, f, g, hg, rfl‚ü©,
  rw is_sieve_consistent_iff at t‚ÇÅ t‚ÇÇ,
  erw [t‚ÇÅ g f ‚ü®_, _, g, hg, id_comp _‚ü©, t‚ÇÇ g f ‚ü®_, _, g, hg, id_comp _‚ü©],
  congr' 1,
  apply congr_fun (congr_fun (congr_fun h _) g) hg,
end

@[simp]
lemma extend_restrict {x : family_of_elements P (generate R)} (t : x.consistent) :
  (x.restrict (le_generate R)).sieve_extend = x :=
begin
  apply restrict_inj,
  { exact (t.restrict (le_generate R)).sieve_extend _ },
  { exact t },
  rw restrict_extend,
  exact t.restrict (le_generate R),
end

def is_amalgamation_for (x : family_of_elements P R)
  (t : P.obj (opposite.op X)) : Prop :=
‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : R f), P.map f.op t = x f h

lemma is_consistent_of_exists_amalgamation (x : family_of_elements P R)
  (h : ‚àÉ t, is_amalgamation_for x t) : x.consistent :=
begin
  cases h with t ht,
  intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm,
  rw [‚Üêht _ h‚ÇÅ, ‚Üêht _ h‚ÇÇ, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, comm],
  simp,
end

lemma is_amalgamation_for_restrict {R‚ÇÅ R‚ÇÇ : presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ)
  (x : family_of_elements P R‚ÇÇ) (t : P.obj (opposite.op X)) (ht : is_amalgamation_for x t) :
  is_amalgamation_for (x.restrict h) t :=
Œª Y f hf, ht f (h Y hf)

lemma is_amalgamation_for_extend {R : presieve X}
  (x : family_of_elements P R) (t : P.obj (opposite.op X)) (ht : is_amalgamation_for x t) :
  is_amalgamation_for x.sieve_extend t :=
begin
  intros Y f hf,
  dsimp [family_of_elements.sieve_extend],
  rw [‚Üêht _, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, (some_spec (some_spec (some_spec hf))).2],
end

def is_separated_for (P : C·µí·µñ ‚•§ Type v) (R : presieve X) : Prop :=
‚àÄ (x : family_of_elements P R) (t‚ÇÅ t‚ÇÇ),
  is_amalgamation_for x t‚ÇÅ ‚Üí is_amalgamation_for x t‚ÇÇ ‚Üí t‚ÇÅ = t‚ÇÇ

lemma is_separated_for.ext {R : presieve X} (hR : is_separated_for P R)
  {t‚ÇÅ t‚ÇÇ : P.obj (opposite.op X)} (h : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : R f), P.map f.op t‚ÇÅ = P.map f.op t‚ÇÇ) :
t‚ÇÅ = t‚ÇÇ :=
hR (Œª Y f hf, P.map f.op t‚ÇÇ) t‚ÇÅ t‚ÇÇ (Œª Y f hf, h hf) (Œª Y f hf, rfl)

lemma is_separated_for_iff_generate :
  is_separated_for P R ‚Üî is_separated_for P (generate R) :=
begin
  split,
  { intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    apply h (x.restrict (le_generate R)) t‚ÇÅ t‚ÇÇ _ _,
    { exact is_amalgamation_for_restrict _ x t‚ÇÅ ht‚ÇÅ },
    { exact is_amalgamation_for_restrict _ x t‚ÇÇ ht‚ÇÇ } },
  { intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    apply h (x.sieve_extend),
    { exact is_amalgamation_for_extend x t‚ÇÅ ht‚ÇÅ },
    { exact is_amalgamation_for_extend x t‚ÇÇ ht‚ÇÇ } }
end

lemma is_separated_for_top (P : C·µí·µñ ‚•§ Type v) : is_separated_for P (‚ä§ : presieve X) :=
Œª x t‚ÇÅ t‚ÇÇ h‚ÇÅ h‚ÇÇ,
begin
  have q‚ÇÅ := h‚ÇÅ (ùüô X) (by simp),
  have q‚ÇÇ := h‚ÇÇ (ùüô X) (by simp),
  simp only [op_id, functor_to_types.map_id_apply] at q‚ÇÅ q‚ÇÇ,
  rw [q‚ÇÅ, q‚ÇÇ],
end

def is_sheaf_for (P : C·µí·µñ ‚•§ Type v) (R : presieve X) : Prop :=
‚àÄ (x : family_of_elements P R), x.consistent ‚Üí ‚àÉ! t, is_amalgamation_for x t

def yoneda_sheaf_condition (P : C·µí·µñ ‚•§ Type v) (S : sieve X) : Prop :=
‚àÄ (f : S.functor ‚ü∂ P), ‚àÉ! g, S.functor_inclusion ‚â´ g = f

example {Œ± : Sort*} {p q : Œ± ‚Üí Prop} : (‚àÄ (x : {a // p a}), q x.1) ‚Üî ‚àÄ a, p a ‚Üí q a :=
begin
  simpa only [subtype.forall, subtype.val_eq_coe],
end

def nat_trans_equiv_consistent_family :
  (S.functor ‚ü∂ P) ‚âÉ {x : family_of_elements P S // x.consistent} :=
{ to_fun := Œª Œ±,
  begin
    refine ‚ü®Œª Y f hf, _, _‚ü©,
    { apply Œ±.app (opposite.op Y) ‚ü®_, hf‚ü© },
    { rw is_sieve_consistent_iff,
      intros Y Z f g hf,
      dsimp,
      rw ‚Üê functor_to_types.naturality _ _ Œ± g.op,
      refl }
  end,
  inv_fun := Œª t,
  { app := Œª Y f, t.1 _ f.2,
    naturality' := Œª Y Z g,
    begin
      ext ‚ü®f, hf‚ü©,
      apply t.2.to_sieve_consistent _,
    end },
  left_inv := Œª Œ±,
  begin
    ext X ‚ü®_, _‚ü©,
    refl
  end,
  right_inv :=
  begin
    rintro ‚ü®x, hx‚ü©,
    refl,
  end }

def yoneda_equiv {F : C·µí·µñ ‚•§ Type v} : (yoneda.obj X ‚ü∂ F) ‚âÉ F.obj (opposite.op X) :=
(yoneda_sections X F).to_equiv.trans equiv.ulift

lemma extension_iff_amalgamation (x : S.functor ‚ü∂ P) (g : yoneda.obj X ‚ü∂ P) :
  S.functor_inclusion ‚â´ g = x ‚Üî is_amalgamation_for (nat_trans_equiv_consistent_family x).1 (yoneda_equiv g) :=
begin
  dsimp [is_amalgamation_for, yoneda_equiv, yoneda_lemma, nat_trans_equiv_consistent_family],
  split,
  { rintro rfl,
    intros Y f hf,
    rw ‚Üê functor_to_types.naturality _ _ g,
    change g.app (opposite.op Y) (f ‚â´ ùüô X) = g.app (opposite.op Y) f,
    simp only [comp_id] },
  { intro h,
    ext Y ‚ü®f, hf‚ü©,
    have : _ = x.app Y _ := h f hf,
    rw [‚Üê this, ‚Üê functor_to_types.naturality _ _ g],
    dsimp,
    simp },
end

lemma equiv.exists_unique_congr {Œ± Œ≤ : Type*} (p : Œ≤ ‚Üí Prop) (e : Œ± ‚âÉ Œ≤) :
  (‚àÉ! (y : Œ≤), p y) ‚Üî ‚àÉ! (x : Œ±), p (e x) :=
begin
  split,
  { rintro ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü©,
    exact ‚ü®e.symm b, by simpa using hb‚ÇÅ, Œª x hx, by simp [‚Üêhb‚ÇÇ (e x) hx]‚ü© },
  { rintro ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü©,
    refine ‚ü®e a, ha‚ÇÅ, Œª y hy, _‚ü©,
    rw ‚Üê equiv.symm_apply_eq,
    apply ha‚ÇÇ,
    simpa using hy },
end

lemma yoneda_condition_iff_sheaf_condition :
  is_sheaf_for P S ‚Üî yoneda_sheaf_condition P S :=
begin
  rw [is_sheaf_for, yoneda_sheaf_condition],
  simp_rw [extension_iff_amalgamation],
  rw equiv.forall_congr_left' nat_trans_equiv_consistent_family,
  rw subtype.forall,
  apply ball_congr,
  intros x hx,
  rw ‚Üê equiv.exists_unique_congr _ _,
  simp,
end

lemma separated_for_and_exists_amalgamation_iff_sheaf_for :
  is_separated_for P R ‚àß (‚àÄ (x : family_of_elements P R), x.consistent ‚Üí ‚àÉ t, is_amalgamation_for x t) ‚Üî is_sheaf_for P R :=
begin
  rw [is_separated_for, ‚Üêforall_and_distrib],
  apply forall_congr,
  intro x,
  split,
  { intros z hx, exact exists_unique_of_exists_of_unique (z.2 hx) z.1 },
  { intros h,
    refine ‚ü®_, (exists_of_exists_unique ‚àò h)‚ü©,
    intros t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    apply (h _).unique ht‚ÇÅ ht‚ÇÇ,
    exact is_consistent_of_exists_amalgamation x ‚ü®_, ht‚ÇÇ‚ü© }
end

lemma is_separated_for.is_sheaf_for (t : is_separated_for P R) :
  (‚àÄ (x : family_of_elements P R), x.consistent ‚Üí ‚àÉ t, is_amalgamation_for x t) ‚Üí
  is_sheaf_for P R :=
begin
  rw ‚Üê separated_for_and_exists_amalgamation_iff_sheaf_for,
  apply and.intro t,
end

noncomputable def is_sheaf_for.amalgamate
  (t : is_sheaf_for P R) (x : family_of_elements P R) (hx : x.consistent) :
  P.obj (opposite.op X) :=
classical.some (t x hx).exists

lemma is_sheaf_for.is_amalgamation_for
  (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.consistent) :
  is_amalgamation_for x (t.amalgamate x hx) :=
classical.some_spec (t x hx).exists

@[simp]
lemma is_sheaf_for.valid_glue
  (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.consistent) (f : Y ‚ü∂ X) (Hf : R f) :
  P.map f.op (t.amalgamate x hx) = x f Hf :=
t.is_amalgamation_for hx f Hf

lemma is_sheaf_for.is_separated_for : is_sheaf_for P R ‚Üí is_separated_for P R :=
Œª q, (separated_for_and_exists_amalgamation_iff_sheaf_for.2 q).1

/-- C2.1.3 in Elephant -/
lemma is_sheaf_for_iff_generate :
  is_sheaf_for P R ‚Üî is_sheaf_for P (generate R) :=
begin
  rw ‚Üê separated_for_and_exists_amalgamation_iff_sheaf_for,
  rw ‚Üê separated_for_and_exists_amalgamation_iff_sheaf_for,
  rw ‚Üê is_separated_for_iff_generate,
  apply and_congr (iff.refl _),
  split,
  { intros q x hx,
    apply exists_imp_exists _ (q _ (hx.restrict (le_generate R))),
    intros t ht,
    simpa [hx] using is_amalgamation_for_extend _ _ ht },
  { intros q x hx,
    apply exists_imp_exists _ (q _ (hx.sieve_extend _)),
    intros t ht,
    simpa [hx] using is_amalgamation_for_restrict (le_generate R) _ _ ht },
end

/--
Every presheaf is a sheaf for the family {ùüô X}.

Elephant: C2.1.5(i)
-/
lemma is_sheaf_for_singleton_iso (P : C·µí·µñ ‚•§ Type v) :
  is_sheaf_for P (presieve.singleton (ùüô X)) :=
begin
  intros x hx,
  refine ‚ü®x _ (presieve.singleton_self _), _, _‚ü©,
  { rintro _ _ ‚ü®rfl, rfl‚ü©,
    simp },
  { intros t ht,
    simpa using ht _ (presieve.singleton_self _) }
end

/--
Every presheaf is a sheaf for the maximal sieve.

Elephant: C2.1.5(ii)
-/
lemma is_sheaf_for_top_sieve (P : C·µí·µñ ‚•§ Type v) :
  is_sheaf_for P ((‚ä§ : sieve X) : presieve X) :=
begin
  rw ‚Üê generate_of_singleton_split_epi (ùüô X),
  rw ‚Üê is_sheaf_for_iff_generate,
  apply is_sheaf_for_singleton_iso,
end

/--
If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that
"being a sheaf for a presieve" is a mathematical or hygenic property.
-/
lemma is_sheaf_for_iso {P' : C·µí·µñ ‚•§ Type v} (i : P ‚âÖ P') : is_sheaf_for P R ‚Üí is_sheaf_for P' R :=
begin
  rw [is_sheaf_for_iff_generate, yoneda_condition_iff_sheaf_condition, is_sheaf_for_iff_generate,
      yoneda_condition_iff_sheaf_condition],
  intros h f,
  obtain ‚ü®g, hg‚ÇÅ, hg‚ÇÇ‚ü© := h (f ‚â´ i.inv),
  refine ‚ü®g ‚â´ i.hom, by simpa [iso.eq_comp_inv] using hg‚ÇÅ, _‚ü©,
  { intros g' hg',
    rw ‚Üê iso.comp_inv_eq,
    apply hg‚ÇÇ,
    rw reassoc_of hg' },
end

/--
If a family of arrows `R` on `X` has a subsieve `S` such that:
* `P` is a sheaf for `S`.
* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`
then `P` is a sheaf for `R`.
-/
lemma is_sheaf_for_subsieve_aux (P : C·µí·µñ ‚•§ Type v) {S : sieve X} {R : presieve X}
  (h : (S : presieve X) ‚â§ R)
  (hS : is_sheaf_for P S)
  (trans : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí is_separated_for P (S.pullback f)) :
  is_sheaf_for P R :=
begin
  rw ‚Üê separated_for_and_exists_amalgamation_iff_sheaf_for,
  refine ‚ü®_, _‚ü©,
  { intros x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    exact hS.is_separated_for _ _ _ (is_amalgamation_for_restrict h x t‚ÇÅ ht‚ÇÅ)
                                    (is_amalgamation_for_restrict h x t‚ÇÇ ht‚ÇÇ) },
  { intros x hx,
    use hS.amalgamate _ (hx.restrict h),
    intros W j hj,
    apply (trans hj).ext,
    intros Y f hf,
    rw [‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp,
        hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict,
        ‚Üêhx (ùüô _) f _ _ (id_comp _)],
    simp },
end

lemma is_sheaf_for_subsieve (P : C·µí·µñ ‚•§ Type v) {S : sieve X} {R : presieve X}
  (h : (S : presieve X) ‚â§ R)
  (trans : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), is_sheaf_for P (S.pullback f)) :
  is_sheaf_for P R :=
is_sheaf_for_subsieve_aux P h (by simpa using trans (ùüô _)) (Œª Y f hf, (trans f).is_separated_for)

/-- A presheaf is separated if it is separated for every sieve in the topology. -/
def is_separated (P : C·µí·µñ ‚•§ Type v) : Prop :=
‚àÄ {X} (S : sieve X), S ‚àà J X ‚Üí is_separated_for P S

/-- A presheaf is a sheaf if it is a sheaf for every sieve in the topology. -/
def is_sheaf (P : C·µí·µñ ‚•§ Type v) : Prop :=
‚àÄ {X} (S : sieve X), S ‚àà J X ‚Üí is_sheaf_for P S

lemma is_sheaf_for_coarser_topology (P : C·µí·µñ ‚•§ Type v) {J‚ÇÅ J‚ÇÇ : grothendieck_topology C} :
  J‚ÇÅ ‚â§ J‚ÇÇ ‚Üí is_sheaf J‚ÇÇ P ‚Üí is_sheaf J‚ÇÅ P :=
Œª h t X S hS, t S (h _ hS)

lemma separated_of_sheaf (P : C·µí·µñ ‚•§ Type v) (h : is_sheaf J P) : is_separated J P :=
Œª X S hS, (h S hS).is_separated_for

/-- The property of being a sheaf is preserved by isomorphism. -/
lemma is_sheaf_iso {P' : C·µí·µñ ‚•§ Type v} (i : P ‚âÖ P') (h : is_sheaf J P) : is_sheaf J P' :=
Œª X S hS, is_sheaf_for_iso i (h S hS)

lemma is_sheaf_yoneda (h : ‚àÄ {X} (S : sieve X), S ‚àà J X ‚Üí yoneda_sheaf_condition P S) :
  is_sheaf J P :=
begin
  intros X S hS,
  rw yoneda_condition_iff_sheaf_condition,
  apply h _ hS,
end

/--
For a topology generated by a basis, it suffices to check the sheaf condition on the basis
presieves only.
-/
lemma is_sheaf_for_pretopology [has_pullbacks C] (K : pretopology C) :
  is_sheaf (K.to_grothendieck C) P ‚Üî (‚àÄ {X : C} (R : presieve X), R ‚àà K X ‚Üí is_sheaf_for P R) :=
begin
  split,
  { intros PJ X R hR,
    rw is_sheaf_for_iff_generate,
    apply PJ (sieve.generate R) ‚ü®_, hR, le_generate R‚ü© },
  { rintro PK X S ‚ü®R, hR, RS‚ü©,
    have gRS : ‚áë(generate R) ‚â§ S,
    { apply gi_generate.gc.monotone_u,
      rwa sets_iff_generate },
    apply is_sheaf_for_subsieve P gRS _,
    intros Y f,
    rw [‚Üê pullback_arrows_comm, ‚Üê is_sheaf_for_iff_generate],
    exact PK (pullback_arrows f R) (K.pullbacks f R hR) }
end

end grothendieck_topology

namespace sieve_equalizer

noncomputable theory

variables {C : Type v} [small_category C]
variables {X : C} (S : sieve X) (P : C·µí·µñ ‚•§ Type v) (J : grothendieck_topology C)

def first_obj : Type v :=
‚àè (Œª (f : Œ£ Y, {f : Y ‚ü∂ X // S f}), P.obj (opposite.op f.1))

def second_obj : Type v :=
‚àè (Œª (f : Œ£ Y Z (g : Z ‚ü∂ Y), {f' : Y ‚ü∂ X // S f'}), P.obj (opposite.op f.2.1))

def first_map : first_obj S P ‚ü∂ second_obj S P :=
pi.lift (Œª fg, pi.œÄ _ (‚ü®_, _, S.downward_closed fg.2.2.2.2 fg.2.2.1‚ü© : Œ£ Y, {f : Y ‚ü∂ X // S f}))

def second_map : first_obj S P ‚ü∂ second_obj S P :=
pi.lift (Œª fg, pi.œÄ _ ‚ü®_, fg.2.2.2‚ü© ‚â´ P.map (fg.2.2.1.op))

def fork_map : P.obj (opposite.op X) ‚ü∂ first_obj S P :=
pi.lift (Œª f, P.map f.2.1.op)

lemma w : fork_map S P ‚â´ first_map S P = fork_map S P ‚â´ second_map S P :=
begin
  apply limit.hom_ext,
  rintro ‚ü®Y, Z, g, f, hf‚ü©,
  simp [first_map, second_map, fork_map],
end

def first_obj_eq_family : first_obj S P ‚âÖ grothendieck_topology.family_of_elements P S :=
{ hom := Œª t Y f hf, pi.œÄ (Œª (f : Œ£ Y, {f : Y ‚ü∂ X // S f}), P.obj (opposite.op f.1)) ‚ü®_, _, hf‚ü© t,
  inv := pi.lift (Œª f x, x _ f.2.2),
  hom_inv_id' :=
  begin
    ext ‚ü®Y, f, hf‚ü© p,
    simpa,
  end,
  inv_hom_id' :=
  begin
    ext x Y f hf,
    apply limits.types.limit.lift_œÄ_apply,
  end }

lemma consistent_iff (x : first_obj S P) :
  ((first_obj_eq_family S P).hom x).consistent ‚Üî first_map S P x = second_map S P x:=
begin
  sorry
end

lemma type_equalizer {X Y Z : Type v} (f : X ‚ü∂ Y) (g h : Y ‚ü∂ Z) (w : f ‚â´ g = f ‚â´ h) :
  (‚àÄ (y : Y), g y = h y ‚Üí ‚àÉ! (x : X), f x = y) ‚Üî nonempty (is_limit (fork.of_Œπ _ w)) :=
begin
  split,
  { intro t,
    apply nonempty.intro,
    apply fork.is_limit.mk',
    intro s,
    refine ‚ü®Œª i, _, _, _‚ü©,
    { apply classical.some (t (s.Œπ i) _),
      apply congr_fun s.condition i },
    { ext i,
      apply (classical.some_spec (t (s.Œπ i) _)).1 },
    { intros m hm,
      ext i,
      apply (classical.some_spec (t (s.Œπ i) _)).2,
      apply congr_fun hm i } },
  { rintro ‚ü®t‚ü© y hy,
    let y' : punit ‚ü∂ Y := Œª _, y,
    have hy' : y' ‚â´ g = y' ‚â´ h := funext (Œª _, hy),
    refine ‚ü®(fork.is_limit.lift' t _ hy').1 ‚ü®‚ü©, congr_fun (fork.is_limit.lift' t y' _).2 ‚ü®‚ü©, _‚ü©,
    intros x' hx',
    suffices : (Œª (_ : punit), x') = (fork.is_limit.lift' t y' hy').1,
      rw ‚Üê this,
    apply fork.is_limit.hom_ext t,
    ext ‚ü®‚ü©,
    apply hx'.trans (congr_fun (fork.is_limit.lift' t _ hy').2 ‚ü®‚ü©).symm },
end

lemma equalizer_sheaf_condition :
  grothendieck_topology.is_sheaf_for P S ‚Üî nonempty (is_limit (fork.of_Œπ _ (w S P))) :=
begin
  split,
  { intro h,
    apply nonempty.intro,
    apply fork.is_limit.mk',
    intro s,
    refine ‚ü®_, _, _‚ü©,
    { intro i,
      have z := congr_fun s.condition i,
      dsimp at z,
      rw ‚Üê consistent_iff at z,
      have := h _ z,
    }

  }
end

end sieve_equalizer


-- def matching_family (P : C·µí·µñ ‚•§ Type v) (S : sieve X) : Type (max u v) :=
-- S.functor ‚ü∂ P

-- def amalgamation {P : C·µí·µñ ‚•§ Type v} {S : sieve X} (Œ≥ : matching_family P S) :=
-- {Œ± : yoneda.obj X ‚ü∂ P // S.functor_inclusion ‚â´ Œ± = Œ≥}

-- @[derive subsingleton]
-- def sheaf_condition_at (S : sieve X) (P : C·µí·µñ ‚•§ Type v) : Type (max u v) :=
-- Œ† (Œ≥ : matching_family P S), unique (amalgamation Œ≥)

-- def sheaf_condition_at_top (P : C·µí·µñ ‚•§ Type v) : sheaf_condition_at (‚ä§ : sieve X) P :=
-- Œª Œ≥,
-- begin
--   refine ‚ü®‚ü®‚ü®inv (‚ä§:sieve X).functor_inclusion ‚â´ Œ≥, _‚ü©‚ü©, _‚ü©,
--   { simp },
--   { rintro ‚ü®a, ha‚ü©,
--     apply subtype.ext,
--     simp [ha] }
-- end

-- @[derive subsingleton]
-- def sheaf_condition (P : C·µí·µñ ‚•§ Type v) : Type (max u v) :=
-- Œ† (X : C) (S ‚àà J X), sheaf_condition_at S P

-- def canonical_map (P : C·µí·µñ ‚•§ Type v) (S : sieve X) : (yoneda.obj X ‚ü∂ P) ‚Üí (S.functor ‚ü∂ P) :=
-- Œª f, S.functor_inclusion ‚â´ f

-- def sheaf_condition2 (P : C·µí·µñ ‚•§ Type v) : Prop :=
-- ‚àÄ X (S : sieve X), S ‚àà J X ‚Üí function.bijective (canonical_map P S)

-- -- noncomputable def sheaf_condition2_equiv (P : C·µí·µñ ‚•§ Type v) : sheaf_condition J P ‚âÉ sheaf_condition2 J P :=
-- -- { to_fun := Œª t X S hS,
-- --   begin
-- --     split,
-- --     { intros Œ±‚ÇÅ Œ±‚ÇÇ hŒ±,
-- --       exact subtype.ext_iff.1 (((t X S _ hS).2 ‚ü®Œ±‚ÇÅ, hŒ±‚ü©).trans ((t X S _ hS).2 ‚ü®Œ±‚ÇÇ, rfl‚ü©).symm) },
-- --     { intros Œ≥,
-- --       exact ‚ü®_, (t X S Œ≥ hS).1.1.2‚ü© }
-- --   end,
-- --   inv_fun := Œª t X S Œ≥ hS,
-- --   begin
-- --     specialize t X S hS,
-- --     rw function.bijective_iff_has_inverse at t,
-- --     choose t ht‚ÇÅ ht‚ÇÇ using t,
-- --     refine ‚ü®‚ü®‚ü®t Œ≥, ht‚ÇÇ Œ≥‚ü©‚ü©, Œª a, _‚ü©,
-- --     cases a with a ha,
-- --     apply subtype.ext,
-- --     dsimp,
-- --     rw [‚Üê ht‚ÇÅ a, ‚Üê ha],
-- --     refl,
-- --   end

-- -- }

-- def matching_family' (P : C·µí·µñ ‚•§ Type v) {c : C} (S : sieve c) :=
-- {x : Œ† {d : C} {f : d ‚ü∂ c}, S.arrows f ‚Üí P.obj (opposite.op d) //
--  ‚àÄ {d e : C} (f : d ‚ü∂ c) (g : e ‚ü∂ d) (h : S.arrows f), x (S.downward_closed h g) = P.map g.op (x h)}

-- def amalgamation' {P : C·µí·µñ ‚•§ Type v} {c : C} {S : sieve c} (Œ≥ : matching_family' P S) :=
-- {y : P.obj (opposite.op c) // ‚àÄ {d : C} (f : d ‚ü∂ c) (hf : S.arrows f), P.map f.op y = Œ≥.1 hf}

-- @[derive subsingleton]
-- def sheaf_condition' (P : C·µí·µñ ‚•§ Type v) : Type (max u v) :=
-- Œ† (c : C) (S : sieve c) (Œ≥ : matching_family' P S), S ‚àà J c ‚Üí unique (amalgamation' Œ≥)

-- def matching_family'_equiv_matching_family (P : C·µí·µñ ‚•§ Type v) :
--   matching_family' P S ‚âÉ matching_family P S :=
-- { to_fun := Œª x, ‚ü®Œª _ t, x.1 t.2, Œª c c' f, funext $ Œª t, x.2 _ _ t.2‚ü©,
--   inv_fun := Œª x, ‚ü®Œª d f hf, x.app _ ‚ü®f, hf‚ü©, Œª d d' f g h, congr_fun (x.2 g.op) ‚ü®f, h‚ü©‚ü©,
--   left_inv := Œª _, subtype.ext $ funext $ Œª _, funext $ Œª _, funext $ Œª _, rfl,
--   right_inv := Œª _, by { ext _ ‚ü®_, _‚ü©, refl } }

-- def amalgamation'_equiv_amalgamation (P : C·µí·µñ ‚•§ Type v) (x : matching_family' P S) :
--   amalgamation (matching_family'_equiv_matching_family P x) ‚âÉ (amalgamation' x) :=
-- { to_fun := Œª Œ≥,
--   { val := Œ≥.1.app _ (ùüô X),
--     property := Œª d f hf,
--     begin
--       have := congr_fun (Œ≥.1.naturality f.op) (ùüô _),
--       dsimp at this,
--       erw ‚Üê this,
--       rw comp_id,
--       have q := congr_arg (Œª t, nat_trans.app t (opposite.op d)) Œ≥.2,
--       dsimp at q,
--       have := congr_fun q ‚ü®f, hf‚ü©,
--       exact this,
--     end },
--   inv_fun := Œª Œ≥,
--   { val :=
--     { app := Œª c f, P.map f.op Œ≥.1,
--       naturality' := Œª c c' f, funext $ Œª g, functor_to_types.map_comp_apply P g.op f Œ≥.1 },
--     property :=
--     begin
--       ext c ‚ü®f, hf‚ü©,
--       apply Œ≥.2,
--     end },
--   left_inv :=
--   begin
--     rintro ‚ü®Œ≥‚ÇÅ, Œ≥‚ÇÇ‚ü©,
--     ext d f,
--     dsimp,
--     rw ‚Üê functor_to_types.naturality _ _ Œ≥‚ÇÅ f.op (ùüô X),
--     dsimp,
--     simp,
--   end,
--   right_inv :=
--   begin
--     intro Œ≥,
--     ext1,
--     apply functor_to_types.map_id_apply,
--   end }

-- def sheaf'_equiv_sheaf (P : C·µí·µñ ‚•§ Type v) :
--   sheaf_condition J P ‚âÖ sheaf_condition' J P :=
-- { hom :=
--   begin
--     intros h c S Œ≥ hS,
--     apply equiv.unique (amalgamation'_equiv_amalgamation _ _).symm,
--     apply h _ _ hS,
--   end,
--   inv :=
--   begin
--     intros h c S hS Œ≥,
--     haveI := h _ _ ((matching_family'_equiv_matching_family P).symm Œ≥) hS,
--     have := equiv.unique (amalgamation'_equiv_amalgamation P ((matching_family'_equiv_matching_family P).symm Œ≥)),
--     simpa using this,
--   end }

-- def finest_topology_sieves (P : C·µí·µñ ‚•§ Type v) : Œ† (X : C), set (sieve X) :=
-- Œª X S, ‚àÄ Y (f : Y ‚ü∂ X), nonempty (sheaf_condition_at (S.pullback f) P)

-- def aux_map {Z : C} (S : sieve X) (Œ± : Z ‚ü∂ Y) (f : Y ‚ü∂ X) :
--   (S.pullback (Œ± ‚â´ f)).functor ‚ü∂ (S.pullback f).functor :=
-- { app := Œª T z, ‚ü®z.1 ‚â´ Œ±, by simpa using z.2‚ü© }.

-- def finest_topology (F : C·µí·µñ ‚•§ Type v) : grothendieck_topology C :=
-- { sieves := finest_topology_sieves F,
--   top_mem' := Œª X Y f,
--   begin
--     rw pullback_top,
--     refine ‚ü®sheaf_condition_at_top _‚ü©,
--   end,
--   pullback_stable' := Œª X Y S f hS Z g,
--   begin
--     rw ‚Üê pullback_comp,
--     apply hS _,
--   end,
--   transitive' := Œª U S hS S' t,
--   begin
--     intros W f,
--     cases hS _ f with hfS,
--     refine ‚ü®Œª œÜ, _‚ü©,
--     let œà : (S.pullback f).functor ‚ü∂ F,
--     { refine ‚ü®_, _‚ü©,
--       { intros V Œ±,
--         have q := t Œ±.2 _ (ùüô _),
--         rw pullback_id at q,
--         apply (classical.choice q (aux_map S' Œ±.1 f ‚â´ œÜ)).1.1.1.app _ (ùüô _) },
--       { intros V‚ÇÅ V‚ÇÇ k,
--         sorry,
--         -- ext1 Œ±,
--         -- dsimp,
--         -- have q‚ÇÅ := t Œ±.2 _ (ùüô _),
--         -- rw pullback_id at q‚ÇÅ,
--         -- let z‚ÇÅ := (classical.choice q‚ÇÅ (aux_map S' Œ±.1 f ‚â´ œÜ)).1.1.1,
--         -- have := k.unop ‚â´ Œ±.1,
--         -- -- have q‚ÇÇ := t (S.downward_closed Œ±.2 k.unop) _ (ùüô _),
--         -- -- rw pullback_id at q‚ÇÇ,
--         -- have q‚ÇÇ : nonempty (sheaf_condition_at (pullback (((pullback f S).functor.map k Œ±).1 ‚â´ f) S') F),
--         --   dsimp [sieve.functor],
--         --   rw assoc,
--         --   have q‚ÇÇ := t (S.downward_closed Œ±.2 k.unop) _ (ùüô _),
--         --   rw pullback_id at q‚ÇÇ,
--         --   apply q‚ÇÇ,
--         -- let z‚ÇÇ := (classical.choice q‚ÇÇ (aux_map S' ((S.pullback f).functor.map k Œ±).1 f ‚â´ œÜ)).1.1.1,
--         -- change z‚ÇÇ.app V‚ÇÇ (ùüô _) = F.map k (z‚ÇÅ.app V‚ÇÅ (ùüô _)),
--         -- have := (classical.choice q‚ÇÇ (aux_map S' ((S.pullback f).functor.map k Œ±).1 f ‚â´ œÜ)).1.1.2,
--       }
--     },
--     refine ‚ü®‚ü®‚ü®(classical.choice (hS _ f) œà).1.1.1, _‚ü©‚ü©, _‚ü©,
--     have := (classical.choice (hS _ f) œà).1.1.2,
--   end
-- }
-- variables (C J)

-- structure Sheaf :=
-- (P : C·µí·µñ ‚•§ Type v)
-- (sheaf_cond : sheaf_condition J P)

-- instance : category (Sheaf C J) := induced_category.category Sheaf.P

end category_theory
